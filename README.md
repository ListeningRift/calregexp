# CalRegExp


> *本项目的主要目的是为了更好的反向推算出所个文本所匹配的正则表达式，网上有很多正则表达式生成工具但都不是反向推算，大部分是由操作者自己选定相似根据，再进行差异概括。*

***

### 相似比较

首先需要清晰在正则表达式中的相似指的是什么，比较得到相同字符，相同字符按相同顺序排列，中间间隔的字符无所谓，后期以此为根据进行差异计算。

所以根据正则表达式的规则，这里的特征本质上来说，其实只是相同字符按相同顺序的排列。

如我想在下面这段话中：

```
Now I want to learn. Because I like learning. So I am learning.
```

匹配出这三句话：

```
I want to learn
I like learning
I am learning
```

很明显正则表达式为 ```/I\s.*?\slearn(ing)?/``` 。

对这组字符串中的三个不同字符串来说，特征字符串就是 ```I\s\slearn``` 。

```
want to
like
am
```
就是差异，包括 ```learn``` 后面的 ```ing``` 也属于差异。

去掉所有字符串中所有不同的字符后，通过计算得到所有的字符顺序，也就是**特征字符串**。取得所有特征的交集，结果便是能匹配出所有文本的共同特征字符串。

得到特征字符串之后，暂且在特征字符串的每个字符中间加上 ```.*？```，简单的概括出差异。

之所以使用的是 ```.*？``` 而不是 ```.*``` 是因为这里推荐使用的是**懒惰匹配**即最短匹配，这样的匹配相对标准，匹配结果是所需结果的几率较大，后期可以考虑通过模式选择更改这里的设置。
